#### 技術

###### React

Reactコンポーネントのデザイン経験（単一責任の原則など）やReactとReduxを使用した開発設計の経験があります

Reduxを使用する基本的なステップを簡潔に説明します：

1. **ストアの作成**： Reduxでは、アプリケーションのすべての状態を「ストア」と呼ばれる一つの大きなオブジェクトで管理します。ストアを作成することで、状態を一箇所で扱うことができます。
2. **アクションの定義**： 状態を変更するためのアクションを定義します。アクションは、「何をするか」を記述するオブジェクトで、通常はタイプ（type）プロパティを含みます。
3. **リデューサーの作成**： アクションが発行されたときに状態の更新をどのように行うかを定義する関数を「リデューサー」と呼びます。リデューサーは、現在の状態とアクションを受け取り、新しい状態を返します。
4. **アクションの発行**： アプリケーションのどこかでアクションを「ディスパッチ」することにより、ストアに保存されている状態を更新します。

**ライフサイクル**

1. **マウント (Mounting)**: コンポーネントが最初にDOMに追加される時。
   - `constructor()`: 初期化。
   - `componentDidMount()`: 初回レンダリング後に呼ばれる。
2. **更新 (Updating)**: プロパティや状態の変更で再レンダリングされる時。
   - `shouldComponentUpdate()`: 再レンダリングするかどうかを決定。
   - `componentDidUpdate()`: 更新後に呼ばれる。
3. **アンマウント (Unmounting)**: コンポーネントがDOMから削除される時。
   - `componentWillUnmount()`: 削除直前に呼ばれる。
4. **エラーハンドリング (Error Handling)**: コンポーネントがエラーをキャッチする時。
   - `componentDidCatch()`: エラーをキャッチしてフォールバックUIを表示。




関数コンポーネントとHooks

関数コンポーネントでは、`useEffect`を使ってライフサイクルを管理します。

1. **マウントおよび更新**:
   - `useEffect(() => { ... })`: マウント時と更新時に実行。
   - `useEffect(() => { ... }, [])`: マウント時のみ実行。
2. **アンマウント**:
   - `useEffect(() => { return () => { ... } }, [])`: アンマウント時に実行。

###### Vue

vue　react

- Vueは直感的で学習が容易なフレームワークで、HTMLベースのテンプレートを使用し、シングルファイルコンポーネントを導入しています。Vueは独自の状態管理ライブラリであるVuexを提供しており、小中規模のアプリケーションに適しています。
- ReactはFacebookによって開発されたコンポーネントベースのライブラリで、JSXを使用してUIを構築します。状態管理には外部ライブラリのReduxをよく利用し、大規模なアプリケーションや複雑なアプリケーションに適しています。

vue的生命周期beforecreate，create，mounted，update，unmonted

Vue.js 2とVue.js 3の主な違い

1. **Composition API**: Vue 3では新しいComposition APIが導入されました。見てわかるように`data`や`methods`などの記述がなくなりスッキリした印象です。 この記述の変化により、TypeScriptがかなり扱いやすくなるそうです。
2. **パフォーマンスの向上**: Vue 3は内部的にリライトされ、仮想DOMの改良、コンパイル時間の最適化、およびTree Shakingのサポートが強化されています。これにより、アプリケーションの起動速度とランタイムのパフォーマンスが向上しています。
3. **より良いTypeScriptのサポート**: Vue 3はTypeScriptとの統合が向上しており、TypeScriptを使った開発がよりスムーズに行えます。
4. **複数のルートフラグメント**: Vue 2ではコンポーネントのテンプレートで単一のルート要素が必要でしたが、Vue 3では複数のルート要素が許可されています。
5. **その他の新機能**: Vue 3には、より良いエラーハンドリング、カスタムレンダラAPIの導入、より効果的なコンポーネントキャッシングなど、多くの新機能が追加されています。

###### typescript

静的型付け、￥コードを実行する前、コンパイルの段階でエラーの検出ができるように改良されました。これによって、プログラムの動作がより安定します。　大規模　長期的なプロジェクトのメンテナンスが容易になります。多くのモダンな開発ツールやライブラリがTypeScriptの利用を前提に設計されています。これにより、より堅牢な開発環境を構築することができます。

Tailwind、CSS-in-JS

TDD　**まずテストコードを書いた後にそのテストをパスするようにプロダクト本体を実装する開発手法**

技术提案，具体的内容，比如flask

从零开始，如果是你会怎么选fmamewolk比如github上的star，上传的频率来选



react的生命周期

axios

[JavaScript](https://kinsta.com/jp/knowledgebase/what-is-javascript/#what-is-javascript)バンドラー webpack

JavaScriptのモジュール化が可能。複数のJavaScriptファイルを一つまたは数個のバンドルにまとめることで、HTTPリクエストの数を減らし、ロード時間を短縮します。

Viteは、ESモジュールを利用してブラウザで直接モジュールを読み込むため、初期のサーバー起動が非常に速く

非同期処理では、特定の処理が完了するのを待たずに次の処理を進めることができます。例えば、サーバーからのデータ取得やファイル読み込みなど、時間がかかる処理をバックグラウンドで実行し、その完了を待っている間に他のスクリプトを実行することができます。

###### Javascript

**JSのコールバック関数**

1. **非同期処理の管理**： JavaScriptでよく見られる非同期処理、例えばWeb APIの呼び出しやファイル操作、タイマー処理などにおいて、特定の操作が完了した後に実行したい処理をコールバック関数として定義します。これにより、プログラムの主流れがブロックされることなく、バックグラウンドでの処理完了を待つことができます。
2. **イベントリスナーとしての使用**： ユーザーからの入力やシステムからのイベントを捕捉する際にも、コールバック関数が用いられます。例えば、ボタンクリックやキーボード入力のイベントに対応するために、イベントリスナー内でコールバック関数を指定し、イベント発生時に特定の動作を行わせることが可能です。

コールバック関数の使用例

```
javascript
Copy code
function processData(callback) {
    // 何らかのデータ処理
    let data = "processed data";
    callback(data); // 処理が完了したらコールバック関数を呼び出す
}

function displayData(data) {
    console.log(data); // コールバック関数でデータを表示
}

processData(displayData); // displayData関数をコールバックとして渡す
```

この例では、`processData`関数内でデータ処理を行い、処理が終わった後に`displayData`というコールバック関数を呼び出しています。このようにして、データ処理の完了後にデータを表示する処理を実行しています。

**eslint**

 JavaScriptのコードが規約に沿って書かれているか、指定したルールに違反していないかをチェックをして指摘や修正をしてくれる静的解析ツールです。

cicd

フロントエンドのCI/CDは、開発効率とコード品質の向上を目的とした自動化プロセスです。主な特徴は以下の通りです：

1. **継続的インテグレーション（CI）**：
   - コードを自動ビルドし、テストを実施して問題がないか確認します。
2. **継続的デリバリー（CD）**：
   - テスト通過後、コードを自動的に本番環境にデプロイします。
3. **ツール**：
   - Jenkins、Travis CI、CircleCIなどが一般的です。

このプロセスにより、迅速なリリースと品質の維持が可能になります。

###### **CSS**

＜OOCSSの原則＞クラス名が短い・ネーミングが楽

- 構造と見た目の分離
- コンテナーとコンテンツを分離

###### 設計

基本設計

- **目的**：システムの全体像を把握し、主要な機能と構造を定義する。
- **内容**：システムのアーキテクチャ、主要機能の概略、データフローの大枠。

詳細設計

- **目的**：実際の開発に必要な具体的な詳細を提供する。
- **内容**：各機能の具体的な実装方法、データベースやインターフェースの詳細、セキュリティやエラー処理の具体策。

基本設計は「何を作るか」を定義し、詳細設計は「どうやって作るか」を詳しく指示します。両段階はソフトウェア開発プロセスの効率的な進行のために重要です。

###### DB

テーブル設計の際に気をつけたこと

1. **正規化**：データの冗長性を避け、効率的なデータ管理を実現するために、適切に正規化を行います。
2. **インデックスの最適化**：クエリのパフォーマンス向上のために、必要な箇所にインデックスを設定します。
3. **データ整合性**：外部キー制約などを用いてデータの整合性を保ちます。

###### レビュー

1. **品質の確保**：コードが要件を満たしているか、バグがないかを確認します。重複していない
2. **可読性**：他の開発者が理解しやすいように、清潔で整理されたコードを心がけます。、命名の観点で気をつけること
3. **ドキュメント**：コードに適切なコメントを付け、ドキュメントを整備しています。

コンポーネントは1つの責任を持つように設計されているか、keyは一意であるか 同じidは使用しないようにする、型とデータの順番は合っているか、CSS重複していないか、対象のページの見た目

**コードの品質を保つためにしてること**

- レビュアーの勉強会(レビュー観点など)
  - 実装力よりレビューで漏れを出さない方が成果に対して手っ取り早い
- コーディング規約の定期的な見直し

**URLが入力されてブラウザに表示されるまでの流れを説明をしてください。**

1、DNSサーバーにドメインを問い合わせる

2、DNSサーバーからブラウザにIPアドレスが返ってくる

3、そのIPアドレスのWEBサーバーにデータを要求

4、WEBサーバーからHTMLやCSS等のデータが返ってきて表示される。

クッキー (Cookie)

クッキーは、サーバーからクライアント（ユーザーのブラウザ）に送られ、ブラウザに小さなデータファイルとして保存される情報のことです。クッキーの主な特徴は以下の通りです：

- **クライアント側で保存される**：ユーザーのデバイスに直接保存されるため、情報はブラウザを閉じても持続します。
- **自動送信**：一度クッキーが設定されると、その後の全てのリクエストに自動的にクッキーが含まれ、サーバーに送信されます。
- **容量制限**：クッキーは、そのサイズが比較的小さい（一般的には4KBまで）です。
- **セキュリティ**：クッキーはセキュリティ上の懸念があるため、重要な情報を保存する場合には適切な暗号化が必要です。また、クロスサイトリクエストフォージェリ（CSRF）などの脆弱性に対処するための設定が必要です。

セッション (Session)

セッションは、サーバー側でユーザーの状態を保持する仕組みです。セッションの特徴は以下の通りです：

- **サーバー側での保存**：ユーザーの情報はサーバー上に保存されるため、クライアントにはセッションIDのみが渡されます。これにより、セキュリティが向上します。
- **有効期限の設定**：セッションは一定時間の活動がない場合やブラウザが閉じられると終了することが一般的です。
- **情報容量**：セッションはクッキーより多くの情報を保存することができます。データはサーバー側にあるため、クライアントのリソースを消費しません。
- **利用の適応性**：ログイン情報などのセンシティブなデータを扱う場合に適しています。

#### 
